#!/usr/bin/env node

var yargs = require('yargs')
	.usage('Usage: check <file> [options]')
    .describe('v', 'Verbose flag. Will print all statements.')
    .describe('r', 'Recrusive flag. Will recursively check required files.')
    .describe('j', 'Will output as a tree.')
    .describe('o', 'if -j, will output json into a file: <file>_log. If a file is given, outputs to that it.')
    .showHelpOnFail(false);

var check   = require('../check.js'),
	colors  = require('colors'),
	fs = require('fs'),
	path = require('path'),
	_ = require('underscore'),
	file = process.argv[2];

if (!file) {
	yargs.showHelp();
	process.exit();
}

file = path.resolve(file);

if (!fs.existsSync(file)) {
	console.error(file, 'doesn\'t exist.');
	process.exit();
} else if (!fs.lstatSync(file).isFile()) {
	console.error(file, 'is not a file.');
	process.exit();
}

var argv = yargs.argv;

if (argv.h) {
	yargs.showHelp();
	process.exit();
}

var sinks = module.exports.sinks = require('../danger.json').sinks;
var sources = module.exports.sources = require('../danger.json').sources;

check.flags.verbose = argv.v;
check.flags.recursive = argv.r;
check.flags.json = argv.j;

if (!argv.j)
	console.log(' ---- '.yellow, file.white);

var scope = new check.Scope({
	sources: sources, sinks: sinks,
	file: file
});

var reports = [];

if (argv.j) {
	find = function(r, name) {
		return _.find(r, function(i) {
			return name.indexOf(i.source.name) === 0;
		});
	};

	/* Creates a report for a source. 
		Keeps adding possible taints untill the source lands into a sink.
	*/
	scope.log = function(type, node, name, value) {
		if (typeof value !== 'string')
			return;
		switch(type) {
			case 'SOURCE':
				this.reports.push({
					source: {
						name: value,
						line: this.file + ':' + check.pos(node)
					}
				});
				break;
			case 'SCE':
			case 'SCES': // Possible taint: call expression containing the source.
				source = find(this.reports, value);
				if (source) {
					if (!source.chain)
						source.chain = [];
					source.chain.push({
						name: name,
						value: value,
						line: this.file + ':' + check.pos(node)
					});
				}
				break;
			case 'SASSIGN':
				break;
			case 'SINK':
				source = find(this.reports, value);
				if (source)
					source.sink = {
						name: name,
						line: this.file + ':' + check.pos(node)
					};
				

				// Flush the report. After finding the sink, we don't want to track it anymore.
				if (this.reports.indexOf(source) != -1) {
					this.reports.splice(this.reports.indexOf(source), 1);
					reports.push(source);
				}
				break;
		}
	};
}

var ast = check.astFromFile(scope.file);
check.traverse(ast, scope);

if (argv.j) {
	if (reports.length !== 0)
		console.log(require('prettyjson').render(reports));
	else
		console.log(colors.green('No vulneralbities found'));
}